# AI Testing Protocols for .NET

Mandatory testing rules for Claude Code-generated C# code.

---

## Core Principle

**Testing is non-negotiable for AI-driven development.**

All code generated by Claude Code must have corresponding tests to validate correctness. AI-generated code requires human-verifiable proof of functionality.

---

## Mandatory Testing Rules

### Rule 1: Test Every New Function with Logic

```csharp
// Generated function
public decimal CalculateDiscount(Order order)
{
    if (order.Total > 1000) return order.Total * 0.15m;
    if (order.Total > 500) return order.Total * 0.10m;
    if (order.Total > 100) return order.Total * 0.05m;
    return 0;
}

// MANDATORY: Corresponding tests
[Theory]
[InlineData(50, 0)]
[InlineData(150, 7.50)]
[InlineData(600, 60)]
[InlineData(1500, 225)]
public void CalculateDiscount_ReturnsCorrectAmount(decimal total, decimal expected)
{
    var order = new Order { Total = total };
    var result = _calculator.CalculateDiscount(order);
    result.Should().Be(expected);
}
```

### Rule 2: Test Every Bug Fix

```csharp
// Bug: Null reference when user has no email
// Fix:
public string GetDisplayName(User user)
{
    return user.Email is not null
        ? $"{user.Name} <{user.Email}>"
        : user.Name;
}

// MANDATORY: Test proves bug existed and fix works
[Fact]
public void GetDisplayName_WhenEmailIsNull_ReturnsNameOnly()
{
    var user = new User { Name = "Alice", Email = null };

    var result = _service.GetDisplayName(user);

    result.Should().Be("Alice");
}

[Fact]
public void GetDisplayName_WhenEmailExists_ReturnsNameWithEmail()
{
    var user = new User { Name = "Alice", Email = "alice@test.com" };

    var result = _service.GetDisplayName(user);

    result.Should().Be("Alice <alice@test.com>");
}
```

### Rule 3: Test Every API Endpoint

```csharp
// Generated endpoint
app.MapPost("/users", async (CreateUserRequest request, IUserService service, CancellationToken ct) =>
{
    var result = await service.CreateAsync(request, ct);
    return Results.Created($"/users/{result.Id}", result);
});

// MANDATORY: Integration tests
[Fact]
public async Task CreateUser_WithValidInput_Returns201()
{
    var request = new CreateUserRequest("Alice", "alice@test.com");

    var response = await _client.PostAsJsonAsync("/users", request);

    response.StatusCode.Should().Be(HttpStatusCode.Created);
    response.Headers.Location.Should().NotBeNull();
}

[Fact]
public async Task CreateUser_WithInvalidEmail_Returns400()
{
    var request = new CreateUserRequest("Alice", "not-an-email");

    var response = await _client.PostAsJsonAsync("/users", request);

    response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
}
```

### Rule 4: Test Error Handling Paths

```csharp
// Generated code with error handling
public async Task<Result<User>> GetUserAsync(string id)
{
    if (string.IsNullOrWhiteSpace(id))
        return Result.Fail<User>("ID cannot be empty");

    var user = await _repository.FindAsync(id);
    if (user is null)
        return Result.Fail<User>("User not found");

    return Result.Ok(user);
}

// MANDATORY: Test each error path
[Fact]
public async Task GetUserAsync_WithEmptyId_ReturnsFailure()
{
    var result = await _service.GetUserAsync("");

    result.IsFailure.Should().BeTrue();
    result.Error.Should().Contain("cannot be empty");
}

[Fact]
public async Task GetUserAsync_WhenUserNotFound_ReturnsFailure()
{
    _repositoryMock
        .Setup(r => r.FindAsync("nonexistent"))
        .ReturnsAsync((User?)null);

    var result = await _service.GetUserAsync("nonexistent");

    result.IsFailure.Should().BeTrue();
    result.Error.Should().Contain("not found");
}
```

---

## When Tests Are MANDATORY

| Scenario | Required Tests |
|----------|----------------|
| New method with business logic | Unit tests covering logic branches |
| Bug fix | Test that reproduces bug + verifies fix |
| API endpoint | Integration tests for success/error cases |
| Data transformation | Unit tests with edge cases |
| Validation logic | Tests for valid/invalid inputs |
| Error handling | Tests for each error path |
| Async operations | Tests verifying async behavior |

---

## When Tests Are OPTIONAL

| Scenario | Reason |
|----------|--------|
| Simple DTOs with no logic | No behavior to test |
| Pure configuration classes | No logic |
| Auto-generated code | Test the generator instead |
| Trivial property wrappers | No meaningful behavior |
| Pass-through methods | Logic tested elsewhere |

---

## AI-Generated Test Quality Standards

### 1. Tests Must Be Meaningful

```csharp
// BAD: Tests nothing meaningful
[Fact]
public void User_CanBeCreated()
{
    var user = new User();
    Assert.NotNull(user);  // Useless test
}

// GOOD: Tests actual behavior
[Fact]
public void User_WhenCreated_HasDefaultValues()
{
    var user = new User();

    user.Id.Should().NotBeNullOrEmpty();
    user.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, TimeSpan.FromSeconds(1));
    user.IsActive.Should().BeTrue();
}
```

### 2. Tests Must Cover Edge Cases

```csharp
// Generated validation
public bool IsValidAge(int age) => age >= 0 && age <= 150;

// MANDATORY: Edge case tests
[Theory]
[InlineData(-1, false)]    // Below minimum
[InlineData(0, true)]      // At minimum
[InlineData(75, true)]     // Normal value
[InlineData(150, true)]    // At maximum
[InlineData(151, false)]   // Above maximum
public void IsValidAge_ReturnsCorrectResult(int age, bool expected)
{
    _validator.IsValidAge(age).Should().Be(expected);
}
```

### 3. Tests Must Be Deterministic

```csharp
// BAD: Non-deterministic
[Fact]
public void ProcessOrder_SetsTimestamp()
{
    _service.ProcessOrder(order);
    order.ProcessedAt.Should().Be(DateTime.Now);  // Flaky!
}

// GOOD: Deterministic
[Fact]
public void ProcessOrder_SetsTimestamp()
{
    var before = DateTime.UtcNow;

    _service.ProcessOrder(order);

    order.ProcessedAt.Should().BeOnOrAfter(before);
    order.ProcessedAt.Should().BeOnOrBefore(DateTime.UtcNow);
}
```

### 4. Tests Must Be Independent

```csharp
// BAD: Tests depend on each other
private static User? _savedUser;

[Fact]
public void Test1_CreateUser()
{
    _savedUser = _service.Create(new CreateUserRequest("Alice", "alice@test.com"));
}

[Fact]
public void Test2_GetUser()
{
    var user = _service.GetById(_savedUser!.Id);  // Depends on Test1!
}

// GOOD: Independent tests
[Fact]
public async Task CreateUser_ReturnsUser()
{
    var result = await _service.CreateAsync(request);
    result.Should().NotBeNull();
}

[Fact]
public async Task GetUser_WhenExists_ReturnsUser()
{
    // Arrange: Create user within test
    var created = await _service.CreateAsync(request);

    // Act
    var result = await _service.GetByIdAsync(created.Id);

    // Assert
    result.Should().NotBeNull();
}
```

---

## Coverage Requirements

### Minimum Thresholds

| Metric | Minimum | Target |
|--------|---------|--------|
| Line coverage | 70% | 80% |
| Branch coverage | 65% | 75% |
| Method coverage | 75% | 85% |

### CI Enforcement

```yaml
# GitHub Actions
- name: Run tests with coverage
  run: dotnet test --collect:"XPlat Code Coverage"

- name: Check coverage threshold
  run: |
    COVERAGE=$(grep -oP 'line-rate="\K[^"]+' coverage.cobertura.xml | head -1)
    if (( $(echo "$COVERAGE < 0.70" | bc -l) )); then
      echo "Coverage $COVERAGE is below 70% threshold"
      exit 1
    fi
```

---

## Test Workflow for AI-Generated Code

### Step 1: Generate Code

```csharp
// AI generates implementation
public async Task<UserDto> CreateUserAsync(CreateUserRequest request, CancellationToken ct)
{
    var validation = await _validator.ValidateAsync(request, ct);
    if (!validation.IsValid)
    {
        throw new ValidationException(validation.Errors.First().ErrorMessage);
    }

    var user = new User { Name = request.Name, Email = request.Email };
    await _repository.AddAsync(user, ct);

    return new UserDto(user.Id, user.Name, user.Email);
}
```

### Step 2: Generate Tests

```csharp
// AI MUST generate corresponding tests
public class UserServiceTests
{
    [Fact]
    public async Task CreateUserAsync_WithValidInput_ReturnsUserDto()
    {
        // Arrange
        var request = new CreateUserRequest("Alice", "alice@test.com");
        SetupValidValidation();
        SetupRepositoryAdd();

        // Act
        var result = await _sut.CreateUserAsync(request, CancellationToken.None);

        // Assert
        result.Should().NotBeNull();
        result.Name.Should().Be("Alice");
        result.Email.Should().Be("alice@test.com");
    }

    [Fact]
    public async Task CreateUserAsync_WithInvalidInput_ThrowsValidationException()
    {
        // Arrange
        var request = new CreateUserRequest("", "invalid");
        SetupInvalidValidation();

        // Act
        var act = () => _sut.CreateUserAsync(request, CancellationToken.None);

        // Assert
        await act.Should().ThrowAsync<ValidationException>();
    }
}
```

### Step 3: Verify Tests Pass

```bash
dotnet test --filter "FullyQualifiedName~UserServiceTests"
```

### Step 4: Verify Coverage

```bash
dotnet test --collect:"XPlat Code Coverage"
# Check that new code is covered
```

---

## Summary

### AI Testing Checklist

- [ ] Every new function with logic has tests
- [ ] Every bug fix includes regression test
- [ ] Every API endpoint has integration tests
- [ ] Every error path is tested
- [ ] Tests are meaningful (not just null checks)
- [ ] Edge cases are covered
- [ ] Tests are deterministic
- [ ] Tests are independent
- [ ] Coverage meets minimum threshold

### Enforcement

Claude Code MUST:
1. Generate tests for all code changes
2. Ensure tests pass before completing task
3. Maintain coverage above threshold
4. Include tests in PRs/commits

---

*Last updated: 2026-01-15*
